<!--docs/content_hub_v2/AXIOM_CONTENT_HUB_v2_SPEC.md-->
# AXIOM_DEMO_UI · CONTENT HUB v2 + READER v1.0  
Техническое задание (Часть 1 — план работ)

## 0. Общие положения

1. Под «ROOT» в этом документе всегда понимается корень репозитория `AXIOM_DEMO_UI`.
2. Все действия выполняются в актуальной ветке, указанной заказчиком  
   (на момент подготовки ТЗ: `feat/content-v2.2/content-hub-v2-reader-v1`).
3. Все изменения кода должны сопровождаться понятными коммит-сообщениями в стиле:
   - `feat(content): ...`
   - `refactor(reader): ...`
   - `chore(content-build): ...`
4. При выполнении каждого пункта этого ТЗ агент обязан:
   - фиксировать **созданные** и **изменённые** файлы;
   - указывать **относительный путь от ROOT**;
   - кратко описывать, что было сделано в этом файле.
   (Формат лога будет задан в отдельном документе — Часть 2.)

---

## 1. Дизайн-референсы (ax-design)

### 1.1. Структура референсных файлов

1. Убедиться, что в репозитории существует каталог:

   - `ROOT/ax-design/preview/`
   - `ROOT/ax-design/reader/`

2. Разместить предоставленные HTML-прототипы в этих каталогах как референсы (только для чтения):

   - `ROOT/ax-design/preview/p_PLACEHOLDER.html`  
   - `ROOT/ax-design/preview/p_PLACEHOLDER_01.html`  
   - `ROOT/ax-design/reader/READER_VIEW.html`

3. Эти файлы не подключаются напрямую в сборку.  
   Их задача — быть эталоном визуального дизайна для:
   - PREVIEW-блока (сплит «портрет слева — текст справа»);
   - READER-окна (шапка + левое меню + зона чтения).

---

## 2. Структура данных контента

Цель: разделить «исходники текста» и «рендер» так, чтобы:

- исходные файлы были в Markdown/HTML;
- интерфейс CONTENT/READER работал только через подготовленные данные и HTML.

### 2.1. Каталог исходников контента

1. Создать каталог:

   - `ROOT/content-src/`

2. В этот каталог должны быть перенесены/созданы исходники AXIOM-файлов:

   Примеры:

   - `ROOT/content-src/03.03_AXIOM.md`
   - `ROOT/content-src/03.01_VIKTOR.md`
   - и т.д. для остальных файлов, которые должны отображаться в CONTENT/READER.

3. Формат каждого `.md`:

   - Вверху — `front-matter` в формате YAML.
   - Ниже — чистый Markdown-текст.

   Минимальный набор полей в `front-matter`:

```yaml
   ---
   id: 03.03_AXIOM
   title: "AXIOM — центральная ИИ-сущность"
   zone: "03_CHARACTERS"
   category: "CENTRAL-AI"
   status: "published"          # или draft
   lang: "ru"                   # ru / en
   version: "v2.1"
   image: "/assets/content/03.03_AXIOM.png"
   tags:
     - "AI"
     - "CENTRAL-AI"
     - "LIMBO"
     - "CRYPT"
   preview_kicker: "ZONE · 03_CHARACTERS · STATUS: PUBLISHED"
   preview_logline: "Падший сверхразум Эшелона; фрагментирован (LIMBO/CRYPT/эхо)…"
   preview_markers:
     - "Центральный узел конфликта мира и мифологии"
     - "Фрагментирован LIMBO/CRYPT/эхо"
     - "Связь с AXIOM_SHADOW_NET"
   preview_signature:
     - "Палитра: красный/чёрный"
     - "Поведение: призрачный надзиратель"
     - "Опорный узел: 01_CORE_SYSTEM"
   ---
```

Всё, что ниже `---`, считается основным контентом файла.

4. Агент обязан:

   * перечислить все существующие сейчас файлы контента (по состоянию ветки);
   * для каждого создать/подготовить соответствующий `.md` в `content-src/`;
   * сохранить связь `id` ↔ оригинальное имя файла.

### 2.2. Каталог готового HTML

1. Создать каталог для отрендеренных HTML-файлов:

   * `ROOT/public/content-html/`

2. Для каждого `id` из `content-src/*.md` в этом каталоге должен появляться одноимённый HTML-файл:

   * `ROOT/public/content-html/03.03_AXIOM.html`
   * `ROOT/public/content-html/03.01_VIKTOR.html`
   * и т.д.

3. Внутри HTML:

   * содержится только тело документа (без `<html>`, `<head>`, `<body>`), готовое к вставке в `<article class="axr-body">` READERa;
   * заголовок `h1` может быть либо сгенерирован из `title`, либо взят из Markdown.

### 2.3. Индекс контента (JSON)

1. Создать каталог для данных:

   * `ROOT/src/features/content/data/`

2. Создать файл индекса:

   * `ROOT/src/features/content/data/content-index.json`

3. Формат одной записи в этом JSON:

   ```json
   {
     "id": "03.03_AXIOM",
     "slug": "axiom-central-ai",
     "title": "AXIOM — центральная ИИ-сущность",
     "zone": "03_CHARACTERS",
     "category": "CENTRAL-AI",
     "status": "published",
     "lang": "ru",
     "version": "v2.1",
     "tags": ["AI", "CENTRAL-AI", "LIMBO", "CRYPT"],
     "preview": {
       "kicker": "ZONE · 03_CHARACTERS · STATUS: PUBLISHED",
       "logline": "Падший сверхразум Эшелона; фрагментирован (LIMBO/CRYPT/эхо)…",
       "markers": [
         "Центральный узел конфликта мира и мифологии",
         "Фрагментирован LIMBO/CRYPT/эхо",
         "Связь с AXIOM_SHADOW_NET"
       ],
       "signature": [
         "Палитра: красный/чёрный",
         "Поведение: призрачный надзиратель",
         "Опорный узел: 01_CORE_SYSTEM"
       ],
       "image": "/assets/content/03.03_AXIOM.png"
     }
   }
   ```

4. Агент обязан:

   * обеспечить однозначное соответствие между `content-src/*.md`, `public/content-html/*.html` и `content-index.json` по полю `id`;
   * гарантировать уникальность `id` и `slug`.

### 2.4. Скрипт сборки контента

1. Создать каталог для скриптов сборки:

   * `ROOT/scripts/`

2. Создать файл:

   * `ROOT/scripts/build-content.ts` (или `.js` в зависимости от принятого стандарта в проекте).

3. Обязанности скрипта:

   1. Пройти по всем файлам `ROOT/content-src/*.md`.
   2. Для каждого:

      * считать front-matter и тело Markdown;
      * сформировать объект для записи в `content-index.json`;
      * отрендерить тело Markdown в HTML и сохранить в `public/content-html/<id>.html`.
   3. Перезаписать файл `content-index.json` актуальным массивом записей.

4. В `package.json` добавить NPM-скрипт:

   * `build:content` — запускает `scripts/build-content.*`.
   * Основной `build` должен вызывать `build:content` **до** сборки Vite (например: `"build": "npm run build:content && vite build"`).

5. Агент обязан:

   * перечислить, какие пакеты были добавлены в `devDependencies` для работы скрипта;
   * описать формат ошибки, если при сборке контента обнаружена некорректная структура `front-matter`.

---

## 3. CONTENT HUB (страница списка + превью)

### 3.1. Структура файлов UI

1. Создать каталог:

   * `ROOT/src/features/content/components/`
   * `ROOT/src/features/content/pages/`

2. Создать компоненты:

   * `ROOT/src/features/content/components/ContentPreview.tsx`
   * `ROOT/src/features/content/components/ContentSidebar.tsx`
   * `ROOT/src/features/content/pages/ContentHubPage.tsx`

3. Компонент `ContentHubPage` будет использоваться как основная страница вкладки **CONTENT**.

### 3.2. Компонент ContentSidebar

1. Назначение:

   * отображать список всех записей из `content-index.json`;
   * показывать активный элемент;
   * давать поиск по id/title/tags.

2. Основные требования:

   * Вёрстка и визуальный стиль должны следовать текущему дизайну панели CONTENT (Red Protocol).
   * Стиль повторяет идею левого меню READER (узкая колонка, круглые вводы, красные подсветки).

3. Поведение:

   * По умолчанию выбран первый элемент из индекса.
   * При клике на элемент:

     * вызывается `onSelect(id: string)`;
     * визуально подсвечивается активный (аналог `axr-menu-item--active`).

4. Контракт пропсов (словесно):

   * Вход:

     * `entries` — массив записей из `content-index.json`;
     * `selectedId` — id выбранной записи;
     * `onSelect(id)` — коллбек для смены выбранного id.
   * Внутри компонент **не** грузит данные сам, а работает только с переданными.

### 3.3. Компонент ContentPreview

1. Назначение:

   * рендер одного превью карточки в стиле `p_PLACEHOLDER.html` / `p_PLACEHOLDER_01.html`.

2. Источник стиля:

   * использовать классы из прототипа (`axcp-...`, или привести к единому неймингу);
   * сохранить:

     * сплит «картинка слева — текст справа»;
     * блоки «ключевые маркеры» и «сигнатура»;
     * нижние чипы/теги;
     * кнопки (минимум одна — `Open source`).

3. Поведение:

   * Пропсы заполняются из одной записи `content-index.json`.
   * Кнопка **Open source**:

     * вызывает переданный коллбек `onOpenSource(id)` либо навигацию на `/content/:id` (в зависимости от того, как реализована маршрутизация в проекте).
   * Дополнительная кнопка (опционально): `Meta` / `View meta` для дальнейшего расширения.

4. Требования по адаптивности:

   * На ширине экрана < 980px:

     * сплит должен превращаться в вертикальный стек (картинка сверху, текст ниже).
   * Верхние отступы/тени — как в design-прототипе.

### 3.4. Страница ContentHubPage

1. Назначение:

   * связать `ContentSidebar` и `ContentPreview` в одном layout;
   * обеспечить выбор файла и переход в READER.

2. Поведение:

   * При загрузке:

     * загрузить `content-index.json` (либо импортировать как статичный JSON).
     * выставить `selectedId`:

       * если в URL есть query-параметр `?id=...` и такой id есть в индексе — выбрать его;
       * иначе — первый элемент в списке.
   * Слева отобразить `ContentSidebar`, справа — `ContentPreview` по текущему `selectedId`.

3. Переход в READER:

   * Кнопка `Open source` в `ContentPreview` должна переводить пользователя на путь вида:

     * `/content/:id` (точный формат согласуется с существующей системой роутинга).
   * Если в проекте уже есть маршрут `/dashboard/content/all`, необходимо:

     * либо переназначить его на `ContentHubPage`,
     * либо встроить `ContentHubPage` как дочернюю страницу текущего маршрута.

4. Агент обязан явно задокументировать:

   * какой файл маршрутизации был изменён (относительный путь);
   * какую точную строку URL он использует для перехода в READER.

---

## 4. READER (окно чтения файла)

### 4.1. Страница ReaderPage

1. Создать файл:

   * `ROOT/src/features/content/pages/ReaderPage.tsx`

2. Назначение:

   * отображать UI READER на основе прототипа `READER_VIEW.html`;
   * загружать и показывать HTML-тело из `public/content-html/<id>.html`.

3. Структура:

   * Верхняя шапка (по классу `axr-header`):

     * кнопка «← Content» возвращает пользователя на `ContentHubPage` (маршрут CONTENT);
     * центр — информация о файле (`[id] vX.X · status · lang`);
     * справа — кнопка-гамбургер для открытия левого меню файлов.
   * Левое меню:

     * откликается на кнопку в шапке;
     * имеет такой же стиль, как описано в прототипе `READER_VIEW.html`;
     * не перекрывает шапку, а начинается строго под ней (как уже реализовано в текущем прототипе).
   * Основная зона:

     * `article.axr-body` с HTML-контентом файла.

### 4.2. Маршрутизация READER

1. В файлах роутинга проекта создать маршрут:

   * `path: "/content/:id"` (либо другой, согласованный с существующим `/dashboard/content/...`).

2. Этот маршрут должен рендерить `ReaderPage`.

3. Поведение при открытии:

   * Извлечь `id` из параметров маршрута.
   * Найти запись в `content-index.json` по этому `id`.
   * Если запись не найдена:

     * отобразить понятное сообщение об ошибке (404 для контента) + кнопку «Назад в CONTENT».
   * Если запись найдена:

     * отобразить её метаданные в шапке;
     * загрузить HTML-контент (см. ниже).

### 4.3. Загрузка HTML и отображение

1. Для идентифицированного `id` нужно загрузить файл:

   * `"/content-html/<id>.html"` (путь относительно `public`).

2. html-тело вставляется в `article.axr-body` через механизм, принятый в проекте (в React обычно `dangerouslySetInnerHTML`).

3. Состояния:

   * Пока HTML грузится:

     * отображать скелетон/лоадер внутри `axr-body` (минимальный: «LOADING …» в стиле Red Protocol).
   * При ошибке загрузки:

     * сообщение «Не удалось загрузить файл» + `id`;
     * кнопка «Назад в CONTENT».
   * При успешной загрузке:

     * отрендеренный HTML без дополнительных обёрток.

4. Требование по безопасности:

   * Считать, что HTML-файлы генерируются только нашим build-скриптом и не содержат стороннего вводимого пользователем кода.

### 4.4. Левое меню READER

1. Источник данных:

   * список файлов формируется на основе `content-index.json`.

2. Поведение:

   * Текущий `id` подсвечивается классом активного элемента (аналог `axr-menu-item--active`).
   * При клике на другой файл:

     * меняется маршрут (`/content/<newId>`).
     * меню закрывается (на мобильных и при узком экране).
   * Поиск:

     * одно поле ввода;
     * фильтрация списка по `id`, `title`, `tags` (строка поиска сравнивается без учёта регистра).

3. Логика отображения:

   * Меню отображается поверх контента с затемнением фона, как в прототипе.
   * Шапка READER остаётся всегда видимой.

---

## 5. Очистка и миграция старой вкладки CONTENT

### 5.1. Поиск старых реализаций

1. Агент должен найти все текущие компоненты и страницы, отвечающие за:

   * вкладку CONTENT;
   * старое окно чтения файлов (если есть);
   * старые превью-карточки.

2. Для этого необходимо:

   * выполнить поиск по проекту по ключевым словам: `"CONTENT"`, `"content hub"`, `"ax-content"`, `"ax-hub"`, `"/dashboard/content"`;
   * перечислить найденные файлы (относительные пути) в отчёте.

### 5.2. Миграция

1. Если старая реализация CONTENT больше не нужна:

   * удалить соответствующие компоненты/страницы;
   * обновить роутинг так, чтобы использовать `ContentHubPage` и `ReaderPage`.

2. Если часть старого кода переиспользуется (например, типы, хуки, вспомогательные функции):

   * эти части можно оставить, но:

     * привести имя файлов/директорий к новому стандарту (`src/features/content/...`);
     * удалить мёртвый код и комментарии, относящиеся к старому дизайну.

3. После миграции:

   * пройтись по всем импортам `CONTENT`/`content` и убедиться, что не осталось ссылок на удалённые файлы;
   * почистить стили (CSS/SCSS), которые больше не используются.

---

## 6. Требования к отчётности агента (кратко)

Полный формат будет определён в отдельной части ТЗ (Часть 2), но уже на этом этапе агент обязан:

1. Для каждого выполненного пункта этого документа фиксировать:

   * какой пункт выполнялся (например: `3.2. ContentSidebar`);
   * какие файлы были созданы;
   * какие файлы были изменены.

2. Для каждого файла указывать:

   * относительный путь от ROOT (например: `src/features/content/pages/ContentHubPage.tsx`);
   * короткое описание сделанных изменений (1–2 предложения).

3. В итоговом отчёте после завершения всех работ по Части 1 дать:

   * список всех новых файлов;
   * список всех удалённых файлов;
   * список всех изменённых файлов.

Формат самого лога/чеклиста, а также шаблоны блоков «Шаг / Статус / Файлы / Комментарий» будут заданы в **Части 2** этого ТЗ.

```

---

Если структура и уровень детализации ок — на следующем шаге сделаем **Часть 2**: подробный формат лога, чеклист по шагам (с полями для статуса, путей, комментариев), чтобы агент мог строго по нему отчитываться.
::contentReference[oaicite:0]{index=0}
```

---

# 7. ЧАСТЬ 2 · ЛОГИКА ОТЧЁТНОСТИ И ЧЕК-ЛИСТЫ

Эта часть описывает, **как агент должен фиксировать ход работ** по Части 1, какие статусы использовать и в каком формате вести лог.

### 7.1. Структура служебных файлов документации

1. Основной файл спецификации (ТЗ):

   - `docs/content_hub_v2/AXIOM_CONTENT_HUB_v2_SPEC.md`  
   - Содержит:
     - Часть 1 — план работ (разделы 0–6);
     - Часть 2 — текущий раздел (7–10).

2. Файл лога по работам над CONTENT HUB v2:

   - `docs/content_hub_v2/AXIOM_CONTENT_HUB_v2_LOG.md`

3. Дополнительно (по необходимости агента) могут быть созданы:

   - `docs/content_hub_v2/AXIOM_CONTENT_HUB_v2_ISSUES.md` — список проблем/багов, которые нельзя закрыть в рамках текущего цикла;
   - `docs/content_hub_v2/AXIOM_CONTENT_HUB_v2_IDEAS.md` — предложения на будущие версии, не входящие в текущий объём ТЗ.

Агент обязан явно указать в отчёте, если создал дополнительные файлы документации: путь и назначение.

---

### 7.2. Система статусов

Для каждого шага и подшага используется фиксированный набор статусов:

- `TODO` — шаг ещё не начат;
- `IN_PROGRESS` — работа в процессе;
- `DONE` — работа выполнена в полном объёме;
- `BLOCKED` — выполнение остановлено по внешним причинам (нет доступа, не хватает данных и т.п.);
- `SKIPPED` — шаг осознанно пропущен (обязательно указать аргументацию в примечании).

В логе статусы записываются **явно** в строке `Status:`.

---

## 8. ГЛОБАЛЬНЫЙ ЧЕК-ЛИСТ ПО БЛОКАМ

Высокоуровневый чек-лист, соответствующий Части 1:

1. `BLOCK A` — Данные и исходники  
   - A.1 — `content-src` (создание и наполнение)  
   - A.2 — `public/content-html` (структура и файлы)  
   - A.3 — `content-index.json` (схема и синхронизация)

2. `BLOCK B` — Скрипт сборки контента  
   - B.1 — файл `scripts/build-content.*`  
   - B.2 — зависимости (devDependencies)  
   - B.3 — интеграция в `package.json` / общий `build`

3. `BLOCK C` — CONTENT HUB (UI)  
   - C.1 — структура файлов `src/features/content/...`  
   - C.2 — `ContentSidebar`  
   - C.3 — `ContentPreview`  
   - C.4 — `ContentHubPage` + роутинг

4. `BLOCK D` — READER (UI)  
   - D.1 — `ReaderPage` (шапка, меню, зона чтения)  
   - D.2 — загрузка HTML `public/content-html/*`  
   - D.3 — маршрутизация `/content/:id`  
   - D.4 — интеграция с CONTENT HUB (кнопка `Open source`)

5. `BLOCK E` — Миграция и очистка  
   - E.1 — аудит старых компонентов CONTENT  
   - E.2 — удаление/перенос устаревших файлов  
   - E.3 — чистка стилей и импортов

6. `BLOCK F` — Проверка и финальное подтверждение  
   - F.1 — базовые сценарии (smoke-тест)  
   - F.2 — проверка сборки `build`  
   - F.3 — финальный обзор и сводный отчёт

Для каждого блока ниже приведены **подробные чек-листы**, которые агент обязан заполнять/отмечать.

---

## 9. ПОДРОБНЫЕ ЧЕК-ЛИСТЫ ПО БЛОКАМ

<!-- AGENT_FOCUS_NOTE_START -->
> **NOTE FOR AGENT / ПРИМЕЧАНИЕ ДЛЯ АГЕНТА**  
> Раздел **9. ПОДРОБНЫЕ ЧЕК-ЛИСТЫ ПО БЛОКАМ** — твой основной рабочий чек-лист.  
> В каждом блоке и подблоке есть пункты, которые ты должен отметить по мере выполнения.  
<!-- AGENT_FOCUS_NOTE_END -->

<!-- AGENT_START_CHECKLIST -->

### 9.1. BLOCK A — Данные и исходники

#### A.1. Каталог `content-src`

Агент отмечает пункты по мере выполнения:

 - [x] A.1.1. Создан каталог `content-src/` в корне репозитория.
 - [x] A.1.2. Для каждого логического файла контента (AXIOM, VIKTOR и др.) определён уникальный `id` (формат: `NN.NN_NAME`).
 - [x] A.1.3. Для каждого файла создан соответствующий Markdown-файл в `content-src/` с корректным `front-matter`.
 - [x] A.1.4. Проверено, что все обязательные поля `front-matter` присутствуют (`id`, `title`, `zone`, `category`, `status`, `lang`, `version`, `image`, `tags`, `preview_*`).
 - [x] A.1.5. Содержимое Markdown после `---` не содержит артефактов разметки, не относящихся к контенту (например, старые HTML-обёртки).

#### A.2. Каталог `public/content-html`

- [x] A.2.1. Создан каталог `public/content-html/`.
- [x] A.2.2. Для каждого `id` из `content-src/*.md` существует файл `public/content-html/<id>.html`.
- [x] A.2.3. Внутри `*.html` содержится только тело, корректно вставляемое в `<article class="axr-body">`.
- [x] A.2.4. Проверено, что HTML не содержит дублирующих `<html>`, `<head>`, `<body>`.

#### A.3. Индекс `content-index.json`

- [x] A.3.1. Создан каталог `src/features/content/data/`.
- [x] A.3.2. Создан файл `src/features/content/data/content-index.json`.
- [x] A.3.3. Для каждого `id` из `content-src/*.md` имеется запись в `content-index.json`.
- [x] A.3.4. Поля JSON соответствуют схеме, описанной в Части 1 (раздел 2.3).
- [x] A.3.5. Проверено, что `id` в JSON совпадает с именами файлов HTML и `id` из `front-matter`.

---

### 9.2. BLOCK B — Скрипт сборки контента

#### B.1. Файл `scripts/build-content.*`

- [x] B.1.1. Создан каталог `scripts/` в корне репозитория.
- [x] B.1.2. Создан файл `scripts/build-content.ts` **или** `scripts/build-content.js`.
- [x] B.1.3. Скрипт обрабатывает все файлы `content-src/*.md`.
- [x] B.1.4. Скрипт для каждого файла формирует HTML в `public/content-html/`.
- [x] B.1.5. Скрипт полностью перезаписывает `content-index.json` актуальными данными.
- [x] B.1.6. При ошибке структуры `front-matter` скрипт завершает работу с понятным сообщением (какой файл, что не так).

#### B.2. Зависимости

- [x] B.2.1. В `package.json` добавлены необходимые библиотеки для парсинга Markdown/`front-matter`.
- [x] B.2.2. Все добавленные пакеты помещены в `devDependencies`, если они используются только на этапе сборки.
- [x] B.2.3. В логе зафиксированы названия и версии добавленных пакетов.

#### B.3. Интеграция в build-процесс

- [x] B.3.1. В `package.json` добавлен скрипт `build:content`.
- [x] B.3.2. Основной скрипт `build` вызывает `build:content` **до** запуска сборки Vite.
- [x] B.3.3. Локально успешно выполнена команда `npm run build:content` (или аналог) без ошибок.
- [x] B.3.4. Локально успешно выполнена команда полного `build` проекта.

---

### 9.3. BLOCK C — CONTENT HUB (UI)

#### C.1. Структура файлов

 - [x] C.1.1. Создан каталог `src/features/content/components/`.
 - [x] C.1.2. Создан каталог `src/features/content/pages/`.
 - [x] C.1.3. Все новые компоненты CONTENT HUB находятся внутри этих каталогов.

#### C.2. Компонент `ContentSidebar`

- [x] C.2.1. Создан файл `src/features/content/components/ContentSidebar.tsx`.
- [x] C.2.2. Компонент принимает на вход список записей и `selectedId`.
- [x] C.2.3. Реализован callback `onSelect(id)`.
- [x] C.2.4. Активный элемент визуально подсвечивается по классу (аналог `axr-menu-item--active`).
- [x] C.2.5. Реализовано поле поиска по `id`, `title` и `tags`.
- [x] C.2.6. Стиль соответствует Red Protocol и не ломает текущую общую тему.

#### C.3. Компонент `ContentPreview`

- [x] C.3.1. Создан файл `src/features/content/components/ContentPreview.tsx`.
- [x] C.3.2. Вёрстка основана на референсах `ax-design/preview/*.html`.
- [x] C.3.3. Все значения (заголовок, логлайн, списки, теги, путь к изображению) приходят через пропсы и не зашиты жёстко.
- [x] C.3.4. Кнопка `Open source` вызывает переданный коллбек или переход к READER.
- [x] C.3.5. Адаптивность: на узких экранах сплит превращается в вертикальный стек.

#### C.4. Страница `ContentHubPage`

- [x] C.4.1. Создан файл `src/features/content/pages/ContentHubPage.tsx`.
- [x] C.4.2. Страница импортирует `content-index.json` и формирует список контента.
- [x] C.4.3. При первой загрузке выбирается корректный `selectedId` (по параметру в урле или по первому элементу списка).
- [x] C.4.4. Страница отображает слева `ContentSidebar`, справа — `ContentPreview`.
- [x] C.4.5. Кнопка `Open source` на превью открывает READER для соответствующего `id`.
- [x] C.4.6. Маршрут CONTENT (существующий) корректно рендерит `ContentHubPage`.

---

### 9.4. BLOCK D — READER (UI)

#### D.1. Страница `ReaderPage`

- [x] D.1.1. Создан файл `src/features/content/pages/ReaderPage.tsx`.
- [x] D.1.2. Вёрстка страницы соответствует прототипу `ax-design/reader/READER_VIEW.html`.
- [x] D.1.3. Реализована верхняя шапка (кнопка `← Content`, блок `id + версия + статус`, гамбургер).
- [x] D.1.4. Реализовано левое меню, которое появляется поверх контента под шапкой.
- [x] D.1.5. Убедиться, что левое меню **не перекрывает** шапку и начинается строго под ней (как зафиксировано в последней версии CSS).

#### D.2. Загрузка HTML-содержимого

- [x] D.2.1. Страница по `id` формирует путь `"/content-html/<id>.html"`.
- [x] D.2.2. Реализована загрузка HTML (через `fetch` или импорты, в зависимости от архитектуры проекта).
- [x] D.2.3. При успешной загрузке HTML вставляется в `<article class="axr-body">`.
- [x] D.2.4. Обработаны состояния:
  - загрузка (лоадер/скелетон),
  - ошибка (понятное сообщение с `id` и кнопкой «Назад»).

#### D.3. Маршрутизация `/content/:id`

- [x] D.3.1. В системе роутинга добавлен маршрут вида `/content/:id` (или эквивалентный).
- [x] D.3.2. Маршрут рендерит `ReaderPage`.
- [x] D.3.3. При отсутствии записи в `content-index.json` по `id` страница показывает 404-экран для контента.
- [x] D.3.4. Кнопка `← Content` возвращает пользователя на страницу CONTENT HUB.

#### D.4. Связь с CONTENT HUB

- [x] D.4.1. Кнопка `Open source` в превью корректно открывает нужный `id` в READER.
- [x] D.4.2. Переход назад из READER возвращает на CONTENT HUB с тем же выбранным `id` (насколько это возможно в рамках текущей системы роутинга/истории).
- [x] D.4.3. Проверено, что при ручном вводе урла `/content/<id>` страница работает корректно и не ломает приложение.

---

### 9.5. BLOCK E — Миграция и очистка

#### E.1. Аудит старых компонентов

- [x] E.1.1. Найдены все старые компоненты/страницы, связанные с CONTENT.
- [x] E.1.2. Список найденных файлов и путей зафиксирован в `AXIOM_CONTENT_HUB_v2_LOG.md`.
- [x] E.1.3. Принято решение для каждого файла: **удалить**, **перенести**, **оставить как есть**.

#### E.2. Удаление/перенос

- [x] E.2.1. Удалены файлы, больше не используемые в новой архитектуре CONTENT HUB.
- [x] E.2.2. Обновлены все импорты, чтобы они ссылались только на актуальные компоненты.
- [ ] E.2.3. Проверено, что после удаления/переноса проект всё ещё собирается (`build` проходит успешно).

#### E.3. Чистка стилей

- [x] E.3.1. Найдены CSS/SCSS файлы/фрагменты, относящиеся к старому CONTENT.
- [x] E.3.2. Мёртвые стили удалены или интегрированы в новые компоненты.
- [ ] E.3.3. Проверено визуально, что обновлённый CONTENT HUB и READER выглядят корректно.

---

### 9.6. BLOCK F — Проверка и финальное подтверждение

#### F.1. Smoke-тесты

- [ ] F.1.1. Открыта страница CONTENT HUB через основной маршрут.
- [ ] F.1.2. Переключение между файлами в левом списке работает (превью обновляется).
- [ ] F.1.3. Поиск в CONTENT HUB корректно фильтрует список.
- [ ] F.1.4. Кнопка `Open source` для нескольких разных записей успешно открывает READER.
- [ ] F.1.5. В READER работает левое меню смены файлов.
- [ ] F.1.6. Проверена работа на разных ширинах экрана (десктоп/узкий экран).

#### F.2. Сборка проекта

- [ ] F.2.1. Выполнен полный `build` проекта (команда зафиксирована в логе).
- [ ] F.2.2. Убедиться, что после `build` в `dist` присутствуют все необходимые артефакты для CONTENT/READER.
- [ ] F.2.3. Зафиксировать в логе возможные предупреждения/варнинги сборки.
- [x] F.2.1. Выполнен полный `build` проекта (команда зафиксирована в логе).
- [ ] F.2.2. Убедиться, что после `build` в `dist` присутствуют все необходимые артефакты для CONTENT/READER.
- [ ] F.2.3. Зафиксировать в логе возможные предупреждения/варнинги сборки.

#### F.3. Финальный отчёт

- [ ] F.3.1. В `AXIOM_CONTENT_HUB_v2_LOG.md` добавлен финальный блок «Summary».
- [ ] F.3.2. В этом блоке:
  - перечислены все ключевые изменения;
  - перечислены все новые файлы;
  - перечислены удалённые файлы;
  - перечислены изменённые файлы;
  - указаны нерешённые проблемы (если есть) и ссылки на них в `ISSUES.md`.
  
<!-- AGENT_END_CHECKLIST -->

---

## 10. ФОРМАТ ЛОГА (`AXIOM_CONTENT_HUB_v2_LOG.md`)

### 10.1. Общая структура файла лога

Файл `docs/content_hub_v2/AXIOM_CONTENT_HUB_v2_LOG.md` должен иметь следующую структуру:

1. Заголовок и мета:
   - Название;
   - Версия ТЗ;
   - Автор/агент;
   - Даты начала и окончания работ.

2. Блок `GLOBAL STATUS`:
   - Таблица со статусами блоков A–F.

3. Серия секций вида `STEP LOG` для подробного описания каждого шага или группы шагов.

4. Финальный блок `SUMMARY`.

### 10.2. Шаблон шапки лога

```md
# AXIOM CONTENT HUB v2 — LOG

- Spec file: `docs/content_hub_v2/AXIOM_CONTENT_HUB_v2_SPEC.md`
- Log file: `docs/content_hub_v2/AXIOM_CONTENT_HUB_v2_LOG.md`
- Agent: <имя или идентификатор агента>
- Started: <YYYY-MM-DD HH:MM (TZ)>
- Finished: <заполняется после завершения всех работ>
- Spec version: v1.0
```

### 10.3. Шаблон блока GLOBAL STATUS

```md
## GLOBAL STATUS

| Block | Name                     | Status      | Comment                          |
|-------|--------------------------|------------|----------------------------------|
| A     | Data & Sources           | TODO       |                                  |
| B     | Content Build Script     | TODO       |                                  |
| C     | Content Hub UI           | TODO       |                                  |
| D     | Reader UI                | TODO       |                                  |
| E     | Migration & Cleanup      | TODO       |                                  |
| F     | QA & Final Confirmation  | TODO       |                                  |
```

Агент обязан обновлять эту таблицу по мере продвижения.

### 10.4. Шаблон записи STEP LOG

Каждый крупный шаг (или связка подшагов) фиксируется в таком формате:

```md
## STEP: A.1 · content-src — создание и наполнение

- Status: DONE
- Date: 2025-11-27 21:45 (MSK)
- Description:
  Создан каталог `content-src/`, перенесены и оформлены исходники для AXIOM и VIKTOR.

**Files created:**
- `content-src/03.03_AXIOM.md` — исходник AXIOM, добавлен front-matter и тело.
- `content-src/03.01_VIKTOR.md` — исходник VIKTOR, добавлен front-matter и тело.

**Files changed:**
- `docs/content_hub_v2/AXIOM_CONTENT_HUB_v2_SPEC.md` — обновлена ссылка на новые пути (если применимо).

**Files removed:**
- _(если нет — явно указать: «нет»)_  

**Notes:**
- Здесь можно описать любые технические детали, важные для будущих ревизий.

**Problems / Risks:**
- Если шаг помечен как BLOCKED или частично выполнен, перечислить причины.
```

Требования:

1. Для каждого блока A–F должно быть как минимум **по одной** такой записи.
2. Если в одном шаге было слишком много изменений, допускается разделение на подпункты (`STEP: A.1.1`, `STEP: A.1.2` и т.п.).
3. В списках файлов указывать **относительные пути от корня репозитория**.

### 10.5. Шаблон финального SUMMARY

```md
## SUMMARY

**Overall status:** DONE

### New files

- `content-src/03.03_AXIOM.md`
- `content-src/03.01_VIKTOR.md`
- `public/content-html/03.03_AXIOM.html`
- `public/content-html/03.01_VIKTOR.html`
- `src/features/content/components/ContentSidebar.tsx`
- `src/features/content/components/ContentPreview.tsx`
- `src/features/content/pages/ContentHubPage.tsx`
- `src/features/content/pages/ReaderPage.tsx`
- `scripts/build-content.ts`
- _(и т.д. — полный список)_

### Changed files

- `package.json` — добавлен скрипт `build:content`, добавлены devDependencies.
- `src/router/...` — обновлён маршрут CONTENT, добавлен маршрут READER.
- ...

### Removed files

- `src/old-content/...` — устаревшая реализация вкладки CONTENT.
- ...

### Open issues / TODO (не закрыты в этом цикле)

- [ ] Пример: добавить мини-превью в левое меню READER.
- [ ] Пример: локализация интерфейса READER на EN.

```

Агент обязан:

1. Заполнить **все разделы SUMMARY**.
2. Обновить `Overall status` на `DONE` только после выполнения всех блоков A–F.
3. Если какие-то задачи остались открытыми, добавить их в раздел `Open issues / TODO` и, при необходимости, продублировать в `AXIOM_CONTENT_HUB_v2_ISSUES.md`.

---

На этом спецификация **Части 2** завершена.
Файл `docs/content_hub_v2/AXIOM_CONTENT_HUB_v2_SPEC.md` в итоговом виде должен содержать **и план работ (Часть 1), и систему логирования/чек-листы (Часть 2)**, чтобы агент мог, опираясь только на этот документ, выполнить и задокументировать всю интеграцию CONTENT HUB v2 + READER.

---

## 11. РАБОЧИЙ БЛОК ЛОГА АГЕНТА

Ниже этой строки агент ведёт свой фактический лог выполнения задач по данному ТЗ  
(формат записей — по разделу 10).
